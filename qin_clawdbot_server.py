#!/usr/bin/env python3
"""
Qin â†’ Clawdbot Bridge Server (with Whisper STT + Menu System)
Receives audio from Qin, transcribes with Whisper, forwards to Clawdbot.

Endpoints:
  GET  /menu   - Get menu config for Qin app
  POST /audio  - Receive audio, transcribe, forward to Clawdbot
  POST /chat   - Receive text, forward to Clawdbot
  GET  /health - Health check
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.request
import json
import os
import re
import socket
import subprocess
import tempfile
import shutil
import time


def strip_markdown(text):
    """Strip markdown formatting for plain-text display on Qin."""
    # Code blocks first (before other processing)
    text = re.sub(r'```[\s\S]*?```', '', text)
    text = re.sub(r'`([^`]+)`', r'\1', text)
    
    # Headers â†’ CAPS (handle ## at start of line)
    text = re.sub(r'^#{1,6}\s*(.+?)$', lambda m: m.group(1).strip().upper(), text, flags=re.MULTILINE)
    
    # Bold/italic (non-greedy, handle multiline)
    text = re.sub(r'\*\*([^*]+)\*\*', r'\1', text)
    text = re.sub(r'\*([^*]+)\*', r'\1', text)
    text = re.sub(r'__([^_]+)__', r'\1', text)
    text = re.sub(r'_([^_]+)_', r'\1', text)
    
    # Links [text](url) â†’ text
    text = re.sub(r'\[([^\]]+)\]\([^)]+\)', r'\1', text)
    
    # Tables â†’ convert to simple list format
    # Remove table header separator lines (|---|---|)
    text = re.sub(r'^\s*\|[-:\s|]+\|\s*$', '', text, flags=re.MULTILINE)
    # Convert table rows: | a | b | c | â†’ a - b - c
    text = re.sub(r'^\s*\|(.+)\|\s*$', lambda m: ' - '.join(c.strip() for c in m.group(1).split('|') if c.strip()), text, flags=re.MULTILINE)
    # Clean up any remaining pipes
    text = re.sub(r'\|', ' ', text)
    
    # Horizontal rules
    text = re.sub(r'^[-*_]{3,}\s*$', '', text, flags=re.MULTILINE)
    
    # Bullet points â†’ dashes
    text = re.sub(r'^\s*[-*+]\s+', '- ', text, flags=re.MULTILINE)
    
    # Numbered lists: keep as-is but clean brackets
    text = re.sub(r'^\[(\d+)\]', r'\1.', text, flags=re.MULTILINE)
    
    # Multiple blank lines â†’ single
    text = re.sub(r'\n{3,}', '\n\n', text)
    
    # Multiple spaces â†’ single
    text = re.sub(r'  +', ' ', text)
    
    return text.strip()

# Clawdbot Gateway API (OpenAI-compatible endpoint)
CLAWDBOT_API = os.getenv("CLAWDBOT_API", "http://127.0.0.1:18789/v1/chat/completions")
CLAWDBOT_TOKEN = os.getenv("CLAWDBOT_TOKEN", "")

# Whisper model (tiny for speed, base for accuracy)
WHISPER_MODEL = os.getenv("WHISPER_MODEL", "small")

PORT = 8081

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU CONFIGURATION
# Fixed items (1-3) are hardcoded in the app.
# Items 4-9 are DYNAMIC - generated by AI based on context.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MENU_CONFIG = {
    "title": "ğŸ¤– QinBot",
    "fixed": {
        "1": {"label": "ğŸ¤ Voice", "type": "voice"},
        "2": {"label": "ğŸ¯ Focus", "type": "instant"},
        "3": {"label": "ğŸ“° News", "type": "instant"}
    },
    "items": {}  # Populated dynamically
}

# Fallback menu if AI unavailable
FALLBACK_MENU = {
    "4": {"label": "ğŸ“§ Emails", "type": "instant", "command": "Check my emails briefly. When showing an individual email, always end with numbered quick reply options: [1] Reply: 'Got it, thanks' [2] Reply: 'I'll handle this' [3] Reply: 'Let's schedule a call' [4] Custom reply (voice) [0] Back to inbox"},
    "5": {"label": "ğŸ“… Calendar", "type": "instant", "command": "What's on my calendar today?"},
    "6": {"label": "ğŸŒ¤ï¸ Weather", "type": "instant", "command": "What's the weather?"},
    "7": {"label": "â° Remind", "type": "voice", "prompt": "What reminder?"},
    "8": {"label": "ğŸ“ Note", "type": "voice", "prompt": "What note?"},
    "9": {"label": "ğŸ” Search", "type": "voice", "prompt": "Search what?"}
}

# Cache for dynamic menu (refresh every 5 minutes)
dynamic_menu_cache = {"items": None, "timestamp": 0}
MENU_CACHE_SECONDS = 300
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


def generate_dynamic_menu():
    """Build menu from REAL data sources â€” no AI guessing."""
    global dynamic_menu_cache

    # Check cache
    now = time.time()
    if dynamic_menu_cache["items"] and (now - dynamic_menu_cache["timestamp"]) < MENU_CACHE_SECONDS:
        return dynamic_menu_cache["items"]

    import datetime
    hour = datetime.datetime.now().hour
    weekday = datetime.datetime.now().strftime("%A")

    menu = {}

    # === Slot 4: Always NEWS (most used) ===
    menu["4"] = {
        "label": "ğŸ“° News Brief",
        "type": "instant",
        "command": "Give me a quick 30-second AI and tech news briefing. What's the most important thing happening today? Be concise."
    }

    # === Slot 5: Always BRAIN (most used feature) ===
    menu["5"] = {
        "label": "ğŸ§  Brain Query",
        "type": "voice",
        "prompt": "What to search?"
    }

    # === Slot 6: Context-aware from REAL data ===
    # Read active threads from brain-sync.json
    try:
        sync_path = os.path.expanduser("~/clawd/memory/brain-sync.json")
        if os.path.exists(sync_path):
            with open(sync_path) as f:
                sync = json.loads(f.read())
            threads = sync.get("activeThreads", [])
            decisions = sync.get("openDecisions", [])
            if decisions:
                # Show first open decision
                decision = decisions[0]
                short = decision[:20] + "..." if len(decision) > 20 else decision
                menu["6"] = {
                    "label": "ğŸ“‹ " + short[:13],
                    "type": "instant",
                    "command": f"What's the status on: {decision}? Give me a quick update and next steps."
                }
            elif threads:
                thread = threads[0]
                short = thread[:20] + "..." if len(thread) > 20 else thread
                menu["6"] = {
                    "label": "ğŸ”¥ " + short[:13],
                    "type": "instant",
                    "command": f"Quick update on: {thread}"
                }
    except Exception:
        pass
    if "6" not in menu:
        menu["6"] = {"label": "ğŸ“§ Emails", "type": "instant",
                      "command": "Check my emails briefly. Summarize unread - who, subject, urgency."}

    # === Slot 7: Weather (always useful, Beit Shemesh only) ===
    menu["7"] = {
        "label": "ğŸŒ¤ï¸ Weather",
        "type": "instant",
        "command": "What's the weather in Beit Shemesh today and tomorrow? Short answer."
    }

    # === Slot 8: Continue last thread ===
    # Read last Qin chat topic from log
    last_topic = None
    try:
        with open("/tmp/qin-server.log") as f:
            lines = f.readlines()
        for line in reversed(lines):
            if "ğŸ“± Chat:" in line:
                topic = line.split("ğŸ“± Chat:")[1].strip()
                if topic and len(topic) > 5 and "menu" not in topic.lower():
                    last_topic = topic
                    break
    except Exception:
        pass

    if last_topic:
        short = last_topic[:18] + "..." if len(last_topic) > 18 else last_topic
        menu["8"] = {
            "label": "ğŸ”„ Continue",
            "type": "instant",
            "command": f"Continue where we left off. Last topic was: {last_topic}. Go deeper."
        }
    else:
        menu["8"] = {
            "label": "ğŸ”„ Go Deeper",
            "type": "instant",
            "command": "Continue the last conversation and go deeper."
        }

    # === Slot 9: Time-aware ===
    if hour < 10:
        # Morning: focus recap
        menu["9"] = {
            "label": "ğŸ¯ Focus Today",
            "type": "instant",
            "command": "What should I focus on today? Check my memory files, open decisions, and active threads. Give me 3 priorities."
        }
    elif hour < 14:
        # Midday: momentum check
        menu["9"] = {
            "label": "âš¡ Momentum",
            "type": "instant",
            "command": "What have I been focused on the last few days? Brief summary of projects, priorities, momentum."
        }
    elif 14 <= hour < 18:
        # Afternoon: what's next
        menu["9"] = {
            "label": "ğŸ“ What's Next",
            "type": "instant",
            "command": "What should I tackle next? Check open decisions and active threads."
        }
    else:
        # Evening: review
        menu["9"] = {
            "label": "ğŸ“Š Day Review",
            "type": "instant",
            "command": "Quick review of what happened today. Check memory files and recent activity."
        }

    dynamic_menu_cache["items"] = menu
    dynamic_menu_cache["timestamp"] = now
    print(f"ğŸ“Š Data-driven menu built: {[menu[k]['label'] for k in sorted(menu.keys())]}")
    return menu


class QinHandler(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        print(f"[Qin] {args[0]}")

    def do_GET(self):
        if self.path == "/health":
            self.send_json({"status": "ok", "service": "qin-clawdbot-bridge"})
        elif self.path == "/menu":
            # Get dynamic menu items
            dynamic_items = generate_dynamic_menu()
            menu = {
                "title": MENU_CONFIG["title"],
                "fixed": MENU_CONFIG["fixed"],
                "items": dynamic_items
            }
            self.send_json(menu)
        elif self.path == "/menu/refresh":
            # Force refresh dynamic menu
            dynamic_menu_cache["timestamp"] = 0
            dynamic_items = generate_dynamic_menu()
            menu = {
                "title": MENU_CONFIG["title"],
                "fixed": MENU_CONFIG["fixed"],
                "items": dynamic_items
            }
            self.send_json(menu)
        elif self.path.startswith("/files/"):
            self.handle_file_serve()
        elif self.path == "/files" or self.path == "/files/":
            self.handle_file_list()
        else:
            self.send_error(404)

    def do_POST(self):
        if self.path == "/audio":
            self.handle_audio()
        elif self.path == "/chat":
            self.handle_chat()
        elif self.path == "/action":
            self.handle_action()
        else:
            self.send_error(404)

    def handle_file_list(self):
        """List available files for download."""
        files_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "shiurim")
        result = []
        if os.path.isdir(files_dir):
            for root, dirs, files in os.walk(files_dir):
                for f in sorted(files):
                    if f.endswith(('.mp3', '.m4a', '.wav', '.ogg', '.apk')):
                        rel = os.path.relpath(os.path.join(root, f), os.path.dirname(os.path.abspath(__file__)))
                        size_mb = os.path.getsize(os.path.join(root, f)) / (1024 * 1024)
                        result.append({"name": f, "path": f"/files/{rel}", "size_mb": round(size_mb, 1)})
        self.send_json({"files": result, "count": len(result)})

    def handle_file_serve(self):
        """Serve a file from the shiurim/ directory."""
        import urllib.parse
        # Strip /files/ prefix and decode URL encoding
        rel_path = urllib.parse.unquote(self.path[7:])  # Remove "/files/"
        # Security: prevent directory traversal
        if ".." in rel_path or rel_path.startswith("/"):
            self.send_error(403, "Forbidden")
            return
        base_dir = os.path.dirname(os.path.abspath(__file__))
        file_path = os.path.join(base_dir, rel_path)
        if not os.path.isfile(file_path):
            self.send_error(404, "File not found")
            return
        # Determine content type
        ext = os.path.splitext(file_path)[1].lower()
        content_types = {
            '.mp3': 'audio/mpeg', '.m4a': 'audio/mp4', '.wav': 'audio/wav',
            '.ogg': 'audio/ogg', '.apk': 'application/vnd.android.package-archive',
        }
        ctype = content_types.get(ext, 'application/octet-stream')
        fsize = os.path.getsize(file_path)
        self.send_response(200)
        self.send_header("Content-Type", ctype)
        self.send_header("Content-Length", str(fsize))
        self.send_header("Content-Disposition", f'attachment; filename="{os.path.basename(file_path)}"')
        self.end_headers()
        with open(file_path, "rb") as f:
            shutil.copyfileobj(f, self.wfile)

    def handle_action(self):
        """Handle a menu action (instant or with voice input)."""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length).decode("utf-8")
            data = json.loads(body)
            
            action_key = data.get("action")
            voice_input = data.get("voice_input", "")
            
            # Get dynamic menu items (uses cache)
            dynamic_items = generate_dynamic_menu()
            
            if action_key not in dynamic_items:
                self.send_json({"error": f"Unknown action: {action_key}"}, status=400)
                return
            
            item = dynamic_items[action_key]
            
            if item["type"] == "instant":
                # Direct command
                command = item["command"]
            else:
                # Voice input with context
                prompt = item.get("prompt")
                if item["label"] == "ğŸ¤ Chat":
                    command = voice_input
                elif item["label"] == "â° Remind":
                    command = f"Set a reminder: {voice_input}"
                elif item["label"] == "ğŸ“ Note":
                    command = f"Add this to today's memory/notes: {voice_input}"
                elif item["label"] == "ğŸ” Search":
                    command = f"Search the web for: {voice_input}"
                else:
                    command = voice_input
            
            print(f"ğŸ¯ Action {action_key}: {command[:50]}...")
            response = self.forward_to_clawdbot(command)
            response = strip_markdown(response)  # Clean for Qin display
            print(f"ğŸ¤– Response: {response[:100]}...")
            
            self.send_json({"response": response})
            
        except Exception as e:
            print(f"âŒ Action error: {e}")
            self.send_json({"error": str(e)}, status=500)

    def handle_audio(self):
        """Receive audio, transcribe with Whisper, optionally send to Clawdbot."""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            if content_length == 0:
                self.send_json({"error": "No audio data"}, status=400)
                return

            transcribe_only = self.headers.get("X-Transcribe-Only", "").lower() == "true"
            audio_data = self.rfile.read(content_length)
            print(f"ğŸ“± Received {len(audio_data)} bytes of audio")

            with tempfile.NamedTemporaryFile(suffix=".3gp", delete=False) as f:
                f.write(audio_data)
                audio_path = f.name

            txt_path = None
            wav_path = None
            
            try:
                wav_path = audio_path.replace(".3gp", ".wav")
                subprocess.run(
                    ["/opt/homebrew/bin/ffmpeg", "-y", "-i", audio_path, "-ar", "16000", "-ac", "1", wav_path],
                    capture_output=True, timeout=30
                )
                
                if not os.path.exists(wav_path) or os.path.getsize(wav_path) == 0:
                    wav_path = audio_path

                print("ğŸ¤ Transcribing...")
                result = subprocess.run(
                    ["/Users/mordechai/.local/bin/whisper", wav_path,
                     "--model", WHISPER_MODEL,
                     "--language", "en",
                     "--initial_prompt", "South African English speaker discussing AI, technology, monotropism, Clawdbot, Brain MCP, SHELET, cron jobs, Israel ecosystem, Torah, Chassidus, kosher phone, QinBot. Names: Mordechai, Shaul, Weinberger. Technical terms: parquet, embeddings, LanceDB, Claude, Anthropic, OpenRouter.",
                     "--output_format", "txt", "--output_dir", "/tmp"],
                    capture_output=True, text=True, timeout=120
                )

                txt_path = "/tmp/" + os.path.basename(wav_path).rsplit(".", 1)[0] + ".txt"
                
                transcript = ""
                if os.path.exists(txt_path):
                    with open(txt_path, "r") as f:
                        transcript = f.read().strip()

                if not transcript and result.stdout:
                    transcript = result.stdout.strip()
                if not transcript:
                    transcript = "(Could not transcribe)"

                print(f"ğŸ“ Transcript: {transcript}")

                if transcribe_only:
                    self.send_json({"transcript": transcript})
                    return

                response_text = self.forward_to_clawdbot(transcript)
                response_text = strip_markdown(response_text)  # Clean for Qin display
                self.send_json({"transcript": transcript, "response": response_text})

            finally:
                for path in [audio_path, wav_path, txt_path]:
                    try:
                        if path and os.path.exists(path):
                            os.unlink(path)
                    except:
                        pass

        except Exception as e:
            print(f"âŒ Audio error: {e}")
            import traceback
            traceback.print_exc()
            self.send_json({"error": str(e)}, status=500)

    def handle_chat(self):
        """Receive text, forward to Clawdbot."""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length).decode("utf-8")

            try:
                data = json.loads(body)
                user_text = data.get("text", body)
            except json.JSONDecodeError:
                user_text = body.strip()

            if not user_text:
                self.send_json({"error": "No text provided"}, status=400)
                return

            print(f"ğŸ“± Chat: {user_text}")
            response_text = self.forward_to_clawdbot(user_text)
            response_text = strip_markdown(response_text)  # Clean for Qin display
            self.send_json({"response": response_text})

        except Exception as e:
            print(f"âŒ Chat error: {e}")
            self.send_json({"error": str(e)}, status=500)

    def forward_to_clawdbot(self, text):
        """Send text to Clawdbot and get response via OpenAI-compatible API."""
        try:
            # Inject instruction for dynamic menus - PREEMPTIVE is the goal
            # Read active context for smarter guessing
            context_hint = ""
            try:
                sync_path = os.path.expanduser("~/clawd/memory/brain-sync.json")
                if os.path.exists(sync_path):
                    with open(sync_path) as f:
                        sync = json.loads(f.read())
                    threads = sync.get("activeThreads", [])[:3]
                    decisions = sync.get("openDecisions", [])[:3]
                    focus = sync.get("weekFocus", "")
                    if threads or decisions:
                        context_hint = f"\nUser's active threads: {'; '.join(threads[:3])}"
                        if decisions:
                            context_hint += f"\nOpen decisions: {'; '.join(decisions[:3])}"
                        if focus:
                            context_hint += f"\nWeek focus: {focus}"
            except Exception:
                pass

            enhanced_text = text + f"""

[QIN INTERFACE â€” 20-QUESTIONS MODE:
User is on a tiny kosher phone. Can ONLY press numbers 1-7 or 0. NO TYPING.
Your superpower: GUESS what he wants next. Play 20-questions â€” each set of options should narrow down his intent.

Think like this: "Given what I just told him, what would Mordechai MOST LIKELY want to do next?"
Be hyper-specific. Not "learn more" but "connect this to SHELET" or "mine Brain for precedent".

Rules:
- End EVERY response with [1]-[7] options
- Options = COMPLETE ACTIONS, hyper-specific to context
- NEVER use [8] or [9] (system reserves those)
- Keep options SHORT (â‰¤25 chars)
- At least one option should be surprising/creative
- [0] â† Back/Menu

Context: Mordechai, South African accent, in Israel. Direct, no fluff.
Primary uses: deep thinking, brainstorming, news, Brain MCP, connecting ideas.
{context_hint}]"""
            
            # OpenAI-compatible format
            payload = json.dumps({
                "model": "clawdbot:main",
                "messages": [{"role": "user", "content": enhanced_text}],
                "user": "qin"  # For session persistence
            }).encode("utf-8")

            headers = {
                "Content-Type": "application/json",
                "x-clawdbot-agent-id": "main"
            }
            if CLAWDBOT_TOKEN:
                headers["Authorization"] = f"Bearer {CLAWDBOT_TOKEN}"

            req = urllib.request.Request(CLAWDBOT_API, data=payload, headers=headers, method="POST")

            with urllib.request.urlopen(req, timeout=120) as resp:
                result = json.loads(resp.read().decode("utf-8"))
                # OpenAI format: response is in choices[0].message.content
                if "choices" in result and len(result["choices"]) > 0:
                    return result["choices"][0]["message"]["content"]
                return result.get("response", result.get("message", str(result)))

        except urllib.error.URLError:
            return self.fallback_cli(text)
        except Exception as e:
            return f"Error: {e}"

    def fallback_cli(self, text):
        """Fallback: use clawdbot CLI."""
        try:
            result = subprocess.run(
                ["/opt/homebrew/bin/clawdbot", "agent", "--message", text, "--session-id", "qin"],
                capture_output=True, text=True, timeout=120
            )
            return result.stdout.strip() or result.stderr.strip() or "No response"
        except Exception as e:
            return f"CLI error: {e}"

    def send_json(self, data, status=200):
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode("utf-8"))


def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "127.0.0.1"


def main():
    if not shutil.which("whisper"):
        print("âš ï¸  whisper not found. Run: pipx install openai-whisper")
    if not shutil.which("ffmpeg"):
        print("âš ï¸  ffmpeg not found. Run: brew install ffmpeg")

    ip = get_local_ip()
    server = HTTPServer(("0.0.0.0", PORT), QinHandler)

    menu_preview = "\n".join([f"  {k}: {v['label']}" for k, v in MENU_CONFIG["items"].items()])

    print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         ğŸ¤– Qin â†’ Clawdbot Bridge (Menu Edition) ğŸ¤–            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Endpoints:
â•‘    GET  http://{ip}:{PORT}/menu     - Menu config
â•‘    POST http://{ip}:{PORT}/action   - Execute action
â•‘    POST http://{ip}:{PORT}/audio    - Voice â†’ Whisper â†’ Chat
â•‘    POST http://{ip}:{PORT}/chat     - Text â†’ Chat
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Menu:
{menu_preview}
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Whisper model: {WHISPER_MODEL}
â•‘  Press Ctrl+C to stop
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")

    server.serve_forever()


if __name__ == "__main__":
    main()
